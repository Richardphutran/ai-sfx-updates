#!/usr/bin/env python3
"""
ğŸ§  Learning Transfer System for Cross-Session Knowledge Sharing
Captures breakthroughs, creates transfer artifacts, saves massive tokens

Usage:
    python3 learning_transfer.py capture "timeline-debugging" "Direct sequence.getInPoint() works" "var inPoint = sequence.getInPoint();" 200
    python3 learning_transfer.py list
    python3 learning_transfer.py export timeline-debugging
    python3 learning_transfer.py import LEARNING_timeline_debugging.md
"""

import json
import time
import sys
import os
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path

class LearningTransfer:
    def __init__(self, knowledge_base_file="cross_session_knowledge.json"):
        self.knowledge_base_file = knowledge_base_file
        self.knowledge_base = self.load_knowledge_base()
    
    def load_knowledge_base(self) -> Dict:
        """Load existing knowledge base or create new one"""
        if os.path.exists(self.knowledge_base_file):
            try:
                with open(self.knowledge_base_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"âš ï¸ Error loading knowledge base: {e}")
                return {'learnings': [], 'last_updated': time.time()}
        
        return {'learnings': [], 'last_updated': time.time()}
    
    def save_knowledge_base(self):
        """Save knowledge base to file"""
        self.knowledge_base['last_updated'] = time.time()
        try:
            with open(self.knowledge_base_file, 'w') as f:
                json.dump(self.knowledge_base, f, indent=2)
        except Exception as e:
            print(f"âŒ Error saving knowledge base: {e}")
    
    def capture_learning(self, topic: str, breakthrough: str, implementation: str, 
                        tokens_saved: int, validation: str = "", category: str = "general"):
        """Capture a new learning for cross-session transfer"""
        
        learning_id = f"{topic}_{int(time.time())}"
        
        learning = {
            'id': learning_id,
            'topic': topic,
            'category': category,
            'breakthrough': breakthrough,
            'implementation': implementation,
            'tokens_saved': tokens_saved,
            'validation': validation,
            'timestamp': time.time(),
            'date_readable': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'confidence_level': "High",  # Based on testing
            'usage_count': 0
        }
        
        # Add to knowledge base
        self.knowledge_base['learnings'].append(learning)
        self.save_knowledge_base()
        
        # Generate transfer artifact
        self.generate_transfer_artifact(learning)
        
        print(f"ğŸ§  Learning captured: {topic}")
        print(f"ğŸ’¾ Knowledge base updated")
        print(f"ğŸ“„ Transfer artifact created: LEARNING_{topic}.md")
        print(f"ğŸª™ Expected token savings: {tokens_saved}")
        
        return learning_id
    
    def generate_transfer_artifact(self, learning: Dict):
        """Generate a ready-to-transfer learning artifact"""
        
        # Determine if implementation is code or text
        is_code = any(char in learning['implementation'] for char in ['{', '}', ';', '(', ')', 'function', 'var ', 'const ', 'def '])
        code_type = "javascript" if any(word in learning['implementation'].lower() for word in ['var ', 'function', 'sequence', 'app.']) else "python"
        
        artifact_content = f"""# ğŸ§  LEARNING TRANSFER: {learning['topic'].upper()}

**Date:** {learning['date_readable']}  
**Category:** {learning['category']}  
**Token Savings:** {learning['tokens_saved']}+ tokens  
**Confidence:** {learning['confidence_level']}

## ğŸ’¡ BREAKTHROUGH DISCOVERED:
{learning['breakthrough']}

## ğŸš€ IMPLEMENTATION (Copy Exactly):
```{code_type if is_code else ''}
{learning['implementation']}
```

## âœ… VALIDATION:
{learning['validation'] if learning['validation'] else 'Tested and verified working'}

## ğŸ“‹ USAGE INSTRUCTIONS:
1. **Copy** the implementation above exactly as shown
2. **Apply** without modifications  
3. **Expect** {learning['tokens_saved']}+ token savings immediately
4. **Validate** with simple test to confirm working

## ğŸ¯ TRANSFER SUMMARY:
- **Problem Solved:** {learning['breakthrough']}
- **Solution Ready:** Copy-paste implementation above
- **Benefit:** Skip rediscovery, save {learning['tokens_saved']}+ tokens
- **Status:** âœ… READY FOR IMMEDIATE USE

---
*Generated by Learning Transfer System - {learning['date_readable']}*
*Transfer this file to other Claude Code session for instant knowledge sharing*
"""
        
        # Save transfer artifact
        artifact_filename = f"LEARNING_{learning['topic'].replace('-', '_')}.md"
        with open(artifact_filename, 'w') as f:
            f.write(artifact_content)
        
        return artifact_filename
    
    def list_learnings(self):
        """List all captured learnings"""
        learnings = self.knowledge_base.get('learnings', [])
        
        if not learnings:
            print("ğŸ“š No learnings captured yet")
            return
        
        print(f"ğŸ§  Learning Transfer System - {len(learnings)} learnings captured")
        print("=" * 60)
        
        # Group by category
        categories = {}
        for learning in learnings:
            cat = learning.get('category', 'general')
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(learning)
        
        for category, items in categories.items():
            print(f"\nğŸ“‚ {category.upper()}:")
            for learning in sorted(items, key=lambda x: x['timestamp'], reverse=True):
                date = learning['date_readable']
                tokens = learning['tokens_saved']
                print(f"  ğŸ§  {learning['topic']} - {tokens} tokens saved ({date})")
                print(f"     ğŸ’¡ {learning['breakthrough'][:60]}...")
        
        total_tokens_saved = sum(l['tokens_saved'] for l in learnings)
        print(f"\nğŸª™ Total potential token savings: {total_tokens_saved}+")
        print(f"ğŸ“ Transfer artifacts available in current directory")
    
    def export_learning(self, topic: str):
        """Export a specific learning as transfer artifact"""
        learnings = [l for l in self.knowledge_base.get('learnings', []) if l['topic'] == topic]
        
        if not learnings:
            print(f"âŒ Learning '{topic}' not found")
            return False
        
        # Get most recent if multiple
        learning = sorted(learnings, key=lambda x: x['timestamp'], reverse=True)[0]
        
        artifact_filename = self.generate_transfer_artifact(learning)
        print(f"âœ… Exported learning to: {artifact_filename}")
        print(f"ğŸš€ Ready to transfer to other Claude Code session")
        
        return artifact_filename
    
    def import_learning_artifact(self, artifact_file: str):
        """Import a learning artifact from another session"""
        if not os.path.exists(artifact_file):
            print(f"âŒ Artifact file not found: {artifact_file}")
            return False
        
        try:
            with open(artifact_file, 'r') as f:
                content = f.read()
            
            # Extract key information from markdown
            lines = content.split('\n')
            topic = "imported_learning"
            breakthrough = ""
            implementation = ""
            tokens_saved = 0
            
            # Parse the artifact
            in_implementation = False
            for line in lines:
                if line.startswith('# ğŸ§  LEARNING TRANSFER:'):
                    topic = line.replace('# ğŸ§  LEARNING TRANSFER:', '').strip().lower().replace(' ', '-')
                elif line.startswith('**Token Savings:**'):
                    try:
                        tokens_saved = int(line.split('**Token Savings:**')[1].split('+')[0].strip())
                    except:
                        tokens_saved = 100  # Default estimate
                elif line.startswith('## ğŸ’¡ BREAKTHROUGH DISCOVERED:'):
                    breakthrough = lines[lines.index(line) + 1].strip()
                elif line.startswith('```') and not in_implementation:
                    in_implementation = True
                elif line.startswith('```') and in_implementation:
                    break
                elif in_implementation:
                    implementation += line + '\n'
            
            # Import as new learning
            learning_id = self.capture_learning(
                topic=topic,
                breakthrough=breakthrough,
                implementation=implementation.strip(),
                tokens_saved=tokens_saved,
                validation="Imported from other session",
                category="imported"
            )
            
            print(f"âœ… Imported learning: {topic}")
            print(f"ğŸª™ Expected token savings: {tokens_saved}")
            print(f"ğŸ§  Ready to use imported knowledge")
            
            return learning_id
            
        except Exception as e:
            print(f"âŒ Error importing artifact: {e}")
            return False
    
    def get_learning_summary(self):
        """Get summary for cross-session transfer"""
        learnings = self.knowledge_base.get('learnings', [])
        
        if not learnings:
            return "No learnings available for transfer"
        
        # Get top learnings by token savings
        top_learnings = sorted(learnings, key=lambda x: x['tokens_saved'], reverse=True)[:5]
        
        summary = "ğŸ§  KNOWLEDGE TRANSFER AVAILABLE:\n\n"
        
        for i, learning in enumerate(top_learnings, 1):
            summary += f"{i}. **{learning['topic']}**: {learning['breakthrough'][:50]}...\n"
            summary += f"   ğŸ’¾ File: LEARNING_{learning['topic'].replace('-', '_')}.md\n"
            summary += f"   ğŸª™ Saves: {learning['tokens_saved']}+ tokens\n\n"
        
        total_savings = sum(l['tokens_saved'] for l in learnings)
        summary += f"ğŸ“Š Total available savings: {total_savings}+ tokens\n"
        summary += f"ğŸš€ Transfer any LEARNING_*.md file to other session for instant knowledge!"
        
        return summary

def main():
    if len(sys.argv) < 2:
        print("""
ğŸ§  Learning Transfer System

Commands:
    capture <topic> <breakthrough> <implementation> <tokens-saved> [validation] [category]
    list
    export <topic>
    import <artifact-file>
    summary
    
Examples:
    python3 learning_transfer.py capture "timeline-debugging" "Direct getInPoint works" "var inPoint = sequence.getInPoint();" 200 "Tested on 3 timelines" "debugging"
    python3 learning_transfer.py list
    python3 learning_transfer.py export timeline-debugging
    python3 learning_transfer.py import LEARNING_timeline_debugging.md
    python3 learning_transfer.py summary
        """)
        return
    
    learner = LearningTransfer()
    command = sys.argv[1]
    
    if command == 'capture':
        if len(sys.argv) < 6:
            print("âŒ Usage: capture <topic> <breakthrough> <implementation> <tokens-saved> [validation] [category]")
            return
        
        topic = sys.argv[2]
        breakthrough = sys.argv[3]
        implementation = sys.argv[4]
        tokens_saved = int(sys.argv[5])
        validation = sys.argv[6] if len(sys.argv) > 6 else ""
        category = sys.argv[7] if len(sys.argv) > 7 else "general"
        
        learner.capture_learning(topic, breakthrough, implementation, tokens_saved, validation, category)
    
    elif command == 'list':
        learner.list_learnings()
    
    elif command == 'export':
        if len(sys.argv) < 3:
            print("âŒ Usage: export <topic>")
            return
        
        topic = sys.argv[2]
        learner.export_learning(topic)
    
    elif command == 'import':
        if len(sys.argv) < 3:
            print("âŒ Usage: import <artifact-file>")
            return
        
        artifact_file = sys.argv[2]
        learner.import_learning_artifact(artifact_file)
    
    elif command == 'summary':
        print(learner.get_learning_summary())
    
    else:
        print(f"âŒ Unknown command: {command}")

if __name__ == "__main__":
    main()
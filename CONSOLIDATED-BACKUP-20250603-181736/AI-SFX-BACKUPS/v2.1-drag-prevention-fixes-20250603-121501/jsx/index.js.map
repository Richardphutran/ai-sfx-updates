{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/utils/samples.ts","../../../src/jsx/aeft/aeft.ts","../../../src/jsx/ame/ame.ts","../../../src/jsx/anim/anim.ts","../../../src/jsx/audt/audt.ts","../../../src/jsx/idsn/idsn.ts","../../../src/jsx/ilst/ilst.ts","../../../src/jsx/kbrg/kbrg.ts","../../../src/jsx/phxs/phxs.ts","../../../src/jsx/utils/utils.ts","../../../src/jsx/ppro/ppro.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.ai.sfx.generator\",\n  displayName: \"AI SFX Generator (Bolt)\",\n  symlink: \"local\",\n  port: 3001, // Different port to avoid conflicts\n  servePort: 5001,\n  startingDebugPort: 9230, // Different debug port\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [\n    { name: \"PPRO\", version: \"[0.0,99.9]\" }, // Premiere Pro only\n  ],\n\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 400,\n  height: 300,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"AI SFX Generator (Bolt)\",\n      autoVisible: true,\n      width: 400,\n      height: 300,\n    },\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"CA\",\n    org: \"Company\",\n    password: \"password\",\n    tsa: [\n      \"http://timestamp.digicert.com/\", // Windows Only\n      \"http://timestamp.apple.com/ts01\", // MacOS Only\n    ],\n    allowSkipTSA: false,\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\nexport const ns = config.id;\nexport const company = config.zxp.org;\nexport const displayName = config.displayName;\nexport const version = config.version;\n","export const helloVoid = (): void => {\n  alert(\"test\");\n};\nexport const helloError = (str: string) => {\n  // Intentional Error for Error Handling Demonstration\n  //@ts-ignore\n  throw new Error(`We're throwing an error`);\n};\n\nexport const helloStr = (str: string) => {\n  alert(`ExtendScript received a string: ${str}`);\n  return str;\n};\nexport const helloNum = (n: number) => {\n  alert(`ExtendScript received a number: ${n.toString()}`);\n  return n;\n};\nexport const helloArrayStr = (arr: string[]) => {\n  alert(\n    `ExtendScript received an array of ${arr.length} strings: ${arr.toString()}`\n  );\n  return arr;\n};\nexport const helloObj = (obj: { height: number; width: number }) => {\n  alert(`ExtendScript received an object: ${JSON.stringify(obj)}`);\n  return {\n    y: obj.height,\n    x: obj.width,\n  };\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from After Effects!\");\n  app.project.activeItem;\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from Media Encoder\");\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from Animate\");\n  document.path;\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from Audtion\");\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from InDesign\");\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from Illustrator\");\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from Bridge\");\n};\n","import {\n  helloVoid,\n  helloError,\n  helloStr,\n  helloNum,\n  helloArrayStr,\n  helloObj,\n} from \"../utils/samples\";\nexport { helloError, helloStr, helloNum, helloArrayStr, helloObj, helloVoid };\nimport { dispatchTS } from \"../utils/utils\";\n\nexport const helloWorld = () => {\n  alert(\"Hello from Photoshop\");\n};\n","import type { EventTS } from \"../../shared/universals\";\nimport { ns } from \"../../shared/shared\";\n\n/**\n * @function dispatchTS Displatches an event to the CEP panel with Type-Safety\n * See listenTS() in the CEP panel for more info\n * @param event The event name to listen for (defined in EventTS in shared/universals.ts)\n * @param callback The callback function to be executed when the event is triggered\n */\nexport const dispatchTS = <Key extends string & keyof EventTS>(\n  event: Key,\n  data: EventTS[Key]\n) => {\n  if (new ExternalObject(\"lib:PlugPlugExternalObject\")) {\n    var eventObj = new CSXSEvent();\n    eventObj.type = `${ns}.${event}`;\n    eventObj.data = JSON.stringify(data);\n    eventObj.dispatch();\n  }\n};\n\nexport const forEach = <T>(\n  arr: T[],\n  callback: (item: T, i: number) => void\n): void => {\n  for (let i = 0; i < arr.length; i++) {\n    callback(arr[i], i);\n  }\n};\n\nexport const map = <T>(\n  arr: T[],\n  callback: (item: T, i: number) => any\n): T[] => {\n  let res = [];\n  for (let i = 0; i < arr.length; i++) {\n    res.push(callback(arr[i], i));\n  }\n  return res;\n};\n\nexport const filter = <T>(\n  arr: T[],\n  func: (item: T, i: number) => boolean\n): T[] => {\n  let res = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (func(arr[i], i)) {\n      res.push(arr[i]);\n    }\n  }\n  return res;\n};\n\nexport const includes = <T>(arr: T[], value: string | number) => {\n  for (let i = 0; i < arr.length; i++) {\n    const element = arr[i];\n    if (element === value) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const indexOf = <T>(arr: T[], value: string | number) => {\n  for (let i = 0; i < arr.length; i++) {\n    const element = arr[i];\n    if (element === value) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n// Joins paths\nexport const join = (...args: string[]) => {\n  const sep = $.os === \"Windows\" ? \"\\\\\" : \"/\";\n  const len = args.length;\n  let res = args[0];\n  for (let i = 1; i < len; i++) {\n    res = res + sep + args[i];\n  }\n  return res;\n};\n","import { dispatchTS } from \"../utils/utils\";\n\n// ============= AI SFX GENERATOR PREMIERE PRO FUNCTIONS =============\n\n// Initialize real-time timeline monitoring automatically\n(function initializeTimelineMonitoring() {\n    try {\n        // Bind to project change event which fires for timeline changes\n        app.bind('onProjectChanged', function() {\n            // Get updated timeline info and dispatch\n            const seq = app.project.activeSequence;\n            if (seq) {\n                const inPoint = seq.getInPoint();\n                const outPoint = seq.getOutPoint();\n                \n                dispatchTS(\"timelineChanged\", {\n                    inPoint: parseFloat(inPoint) || null,\n                    outPoint: parseFloat(outPoint) || null,\n                    duration: (parseFloat(outPoint) - parseFloat(inPoint)) || null\n                });\n            }\n        });\n        \n        // Log success for debugging\n        $.writeln(\"[AI SFX] Timeline monitoring initialized successfully\");\n    } catch (error) {\n        $.writeln(\"[AI SFX] Failed to initialize timeline monitoring: \" + error.toString());\n    }\n})();\n\n/**\n * Get lightweight sequence information for frequent updates\n * Optimized for performance with minimal calculations\n */\nexport const getSequenceInfoLite = () => {\n    try {\n        if (!app || !app.project || !app.project.activeSequence) {\n            return {\n                success: false,\n                error: \"No active sequence\"\n            };\n        }\n        \n        const sequence = app.project.activeSequence;\n        \n        // Only get essential timeline data for UI updates\n        const inPoint = sequence.getInPoint();\n        const outPoint = sequence.getOutPoint();\n        const inPointSeconds = parseFloat(inPoint);\n        const outPointSeconds = parseFloat(outPoint);\n        const hasInPoint = (!isNaN(inPointSeconds) && inPointSeconds >= 0);\n        const hasOutPoint = (!isNaN(outPointSeconds) && outPointSeconds >= 0);\n        \n        return {\n            success: true,\n            sequenceName: sequence.name,\n            hasInPoint,\n            hasOutPoint,\n            inPoint: {\n                seconds: hasInPoint ? inPointSeconds : null,\n                formatted: hasInPoint ? formatTime(inPointSeconds) : \"--:--:--\"\n            },\n            outPoint: {\n                seconds: hasOutPoint ? outPointSeconds : null,\n                formatted: hasOutPoint ? formatTime(outPointSeconds) : \"--:--:--\"\n            },\n            duration: hasInPoint && hasOutPoint ? {\n                seconds: outPointSeconds - inPointSeconds,\n                formatted: formatTime(outPointSeconds - inPointSeconds)\n            } : null\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: error.toString()\n        };\n    }\n};\n\n/**\n * Get comprehensive sequence information including in/out points\n * Uses MVX-style direct access for reliable timeline data\n */\nexport const getSequenceInfo = (): any => {\n    try {\n        if (!app || !app.project || !app.project.activeSequence) {\n            return {\n                success: false,\n                error: \"No active sequence\"\n            };\n        }\n        \n        const sequence = app.project.activeSequence;\n        const result = {\n            success: true,\n            sequenceName: sequence.name,\n            audioTrackCount: sequence.audioTracks.numTracks,\n            videoTrackCount: sequence.videoTracks.numTracks,\n            source: \"Bolt CEP - MVX-style direct access\"\n        };\n        \n        // Get playhead position\n        try {\n            const playhead = sequence.getPlayerPosition();\n            result.playheadPosition = playhead.seconds;\n            result.playhead = {\n                seconds: playhead.seconds,\n                formatted: formatTime(playhead.seconds)\n            };\n        } catch (playheadError) {\n            result.playheadError = playheadError.toString();\n            result.playheadPosition = 0;\n        }\n        \n        // Direct in/out point access (MVX pattern)\n        try {\n            const inPoint = sequence.getInPoint();\n            const inPointSeconds = parseFloat(inPoint);\n            const hasInPoint = (!isNaN(inPointSeconds) && inPointSeconds >= 0);\n            \n            result.inPoint = {\n                seconds: hasInPoint ? inPointSeconds : null,\n                formatted: hasInPoint ? formatTime(inPointSeconds) : \"--:--:--\",\n                isActuallySet: hasInPoint,\n                rawValue: inPoint\n            };\n            result.hasInPoint = hasInPoint;\n            \n        } catch (inError) {\n            result.hasInPoint = false;\n            result.inPointError = inError.toString();\n            result.inPoint = {\n                seconds: null,\n                formatted: \"--:--:--\",\n                isActuallySet: false,\n                error: inError.toString()\n            };\n        }\n        \n        // Direct out point access\n        try {\n            const outPoint = sequence.getOutPoint();\n            const outPointSeconds = parseFloat(outPoint);\n            const hasOutPoint = (!isNaN(outPointSeconds) && outPointSeconds >= 0);\n            \n            result.outPoint = {\n                seconds: hasOutPoint ? outPointSeconds : null,\n                formatted: hasOutPoint ? formatTime(outPointSeconds) : \"--:--:--\",\n                isActuallySet: hasOutPoint,\n                rawValue: outPoint\n            };\n            result.hasOutPoint = hasOutPoint;\n            \n        } catch (outError) {\n            result.hasOutPoint = false;\n            result.outPointError = outError.toString();\n            result.outPoint = {\n                seconds: null,\n                formatted: \"--:--:--\",\n                isActuallySet: false,\n                error: outError.toString()\n            };\n        }\n        \n        // Calculate duration\n        if (result.hasInPoint && result.hasOutPoint && \n            result.inPoint.seconds !== null && result.outPoint.seconds !== null) {\n            const duration = result.outPoint.seconds - result.inPoint.seconds;\n            result.duration = {\n                seconds: duration,\n                formatted: formatTime(duration),\n                isValid: duration > 0\n            };\n            result.hasDuration = duration > 0;\n        } else {\n            result.duration = {\n                seconds: null,\n                formatted: \"--:--:--\",\n                isValid: false\n            };\n            result.hasDuration = false;\n        }\n        \n        // Add sequence length for context\n        try {\n            if (sequence.end) {\n                result.sequenceLength = {\n                    seconds: sequence.end.seconds,\n                    formatted: formatTime(sequence.end.seconds)\n                };\n            }\n        } catch (lengthError) {\n            result.sequenceLengthError = lengthError.toString();\n        }\n        \n        return result;\n        \n    } catch (e) {\n        return {\n            success: false,\n            error: \"Critical error: \" + e.toString(),\n            source: \"Bolt CEP - MVX-style direct access - failed\"\n        };\n    }\n};\n\n/**\n * Import and place audio at specific time with smart track management\n * Uses proven QE API for track creation and collision detection\n */\nexport const importAndPlaceAudioAtTime = (filePath: string, timeSeconds: number, startingTrackIndex: number = 0) => {\n    const result = {\n        success: false,\n        step: \"initialization\",\n        error: \"\",\n        debug: {}\n    };\n    \n    try {\n        // Validate inputs\n        result.step = \"validating_inputs\";\n        if (!filePath || typeof timeSeconds !== 'number') {\n            result.error = \"Invalid parameters: filePath and timeSeconds required\";\n            return result;\n        }\n        \n        // Check app availability\n        result.step = \"checking_app\";\n        if (typeof app === 'undefined' || !app) {\n            result.error = \"app object not available\";\n            return result;\n        }\n        \n        // Check project\n        result.step = \"checking_project\"; \n        if (!app.project) {\n            result.error = \"No project loaded\";\n            return result;\n        }\n        \n        // Check sequence\n        result.step = \"checking_sequence\";\n        if (!app.project.activeSequence) {\n            result.error = \"No active sequence\";\n            return result;\n        }\n        \n        const sequence = app.project.activeSequence;\n        result.debug.sequenceName = sequence.name;\n        result.debug.placementTimeSeconds = timeSeconds;\n        result.debug.placementTimeFormatted = formatTime(timeSeconds);\n        \n        // Import file\n        result.step = \"importing_file\";\n        result.debug.filePath = filePath;\n        \n        const importResult = app.project.importFiles([filePath]);\n        if (!importResult) {\n            result.error = \"Failed to import file\";\n            return result;\n        }\n        \n        // Find imported item\n        result.step = \"finding_imported_item\";\n        const fileName = filePath.split('/').pop();\n        const baseName = fileName.replace(/\\.[^.]*$/, '');\n        result.debug.fileName = fileName;\n        result.debug.baseName = baseName;\n        \n        let importedItem = null;\n        const rootItem = app.project.rootItem;\n        \n        for (let i = 0; i < rootItem.children.numItems; i++) {\n            const item = rootItem.children[i];\n            if (item.name && item.name.indexOf(baseName) !== -1) {\n                importedItem = item;\n                break;\n            }\n        }\n        \n        if (!importedItem) {\n            result.error = \"Could not find imported item in project\";\n            result.debug.searchedFor = baseName;\n            return result;\n        }\n        result.debug.importedItemName = importedItem.name;\n        \n        // Organize into \"AI SFX\" bin\n        result.step = \"organizing_into_bin\";\n        let aiSfxBin = null;\n        \n        // Check if \"AI SFX\" bin exists\n        for (let j = 0; j < rootItem.children.numItems; j++) {\n            const child = rootItem.children[j];\n            if (child.type === ProjectItemType.BIN && child.name === \"AI SFX\") {\n                aiSfxBin = child;\n                break;\n            }\n        }\n        \n        // Create bin if needed\n        if (!aiSfxBin) {\n            try {\n                aiSfxBin = rootItem.createBin(\"AI SFX\");\n                result.debug.createdBin = true;\n            } catch (binError) {\n                result.debug.binError = \"Could not create bin: \" + binError.toString();\n                result.debug.createdBin = false;\n            }\n        } else {\n            result.debug.createdBin = false;\n        }\n        \n        // Move to bin\n        if (aiSfxBin && importedItem) {\n            try {\n                importedItem.moveBin(aiSfxBin);\n                result.debug.movedToBin = \"AI SFX\";\n            } catch (moveError) {\n                result.debug.moveError = \"Could not move to bin: \" + moveError.toString();\n                result.debug.movedToBin = \"failed\";\n            }\n        }\n        \n        // Smart timeline placement with collision detection\n        result.step = \"smart_timeline_placement\";\n        const startingTrackIdx = parseInt(startingTrackIndex) || 0;\n        let finalTrackIndex = -1;\n        const placementAttempts = [];\n        \n        // Function to check collision at specific time (exact same logic as working CEP version)\n        function hasAudioAtTime(track, timeValue) {\n            try {\n                if (!track.clips || track.clips.numItems === 0) {\n                    return false; // No clips = no conflict\n                }\n                \n                // Handle both time object and raw seconds value\n                const timeInSeconds = typeof timeValue === 'object' ? timeValue.seconds : timeValue;\n                \n                for (let i = 0; i < track.clips.numItems; i++) {\n                    const clip = track.clips[i];\n                    const clipStart = clip.start.seconds;\n                    const clipEnd = clip.end.seconds;\n                    \n                    // Check if placement time overlaps with existing clip (with small buffer)\n                    if (timeInSeconds >= (clipStart - 0.1) && timeInSeconds <= (clipEnd + 0.1)) {\n                        return true;\n                    }\n                }\n                return false;\n            } catch (e) {\n                // If we can't check, assume there's a conflict to be safe\n                return true;\n            }\n        }\n        \n        // Find available track\n        let foundAvailableTrack = false;\n        for (let trackIdx = startingTrackIdx; trackIdx < sequence.audioTracks.numTracks; trackIdx++) {\n            const track = sequence.audioTracks[trackIdx];\n            const hasConflict = hasAudioAtTime(track, timeSeconds);\n            \n            placementAttempts.push({\n                trackIndex: trackIdx,\n                hasConflict: hasConflict,\n                timePosition: timeSeconds,\n                trackClipCount: track.clips ? track.clips.numItems : 0,\n                trackName: track.name || `Audio ${trackIdx + 1}`\n            });\n            \n            if (!hasConflict) {\n                finalTrackIndex = trackIdx;\n                foundAvailableTrack = true;\n                result.debug.foundAvailableTrack = trackIdx;\n                break;\n            }\n        }\n        \n        // Create new track if needed (using proven working logic from original CEP)\n        if (!foundAvailableTrack) {\n            result.debug.beforeTrackCreation = sequence.audioTracks.numTracks;\n            result.debug.attemptingNewTrack = true;\n            \n            let newTrack = null;\n            const trackCreationAttempts = [];\n            \n            // First, enable QE API access\n            try {\n                app.enableQE();\n                trackCreationAttempts.push(\"app.enableQE() - SUCCESS\");\n                result.debug.qeEnabled = true;\n            } catch (qeError) {\n                trackCreationAttempts.push(\"app.enableQE() - ERROR: \" + qeError.toString());\n                result.debug.qeEnabled = false;\n            }\n            \n            // Attempt 1: Use QE API to add tracks (Boombox method)\n            if (result.debug.qeEnabled) {\n                try {\n                    const qeSequence = qe.project.getActiveSequence();\n                    if (qeSequence) {\n                        // Use CORRECT QE API syntax with all 7 parameters (like Boombox!)\n                        if (typeof qeSequence.addTracks === 'function') {\n                            // Get current track count to add track at the END\n                            const currentAudioTracks = sequence.audioTracks.numTracks;\n                            \n                            // qe.addTracks(numberOfVideoTracks, afterWhichVideoTrack, numberOfAudioTracks, audioTrackType, afterWhichAudioTrack, numberOfSubmixTracks, submixTrackType)\n                            // Add 1 stereo audio track at the END: (0 video, 0 pos, 1 audio, 1=stereo, currentAudioTracks pos, 0 submix, 0 type)\n                            qeSequence.addTracks(0, 0, 1, 1, currentAudioTracks, 0, 0);\n                            newTrack = true; // QE doesn't return track object\n                            trackCreationAttempts.push(\"qe.addTracks(0,0,1,1,\" + currentAudioTracks + \",0,0) STEREO AT END - SUCCESS\");\n                        } else {\n                            trackCreationAttempts.push(\"qe.addTracks() - NOT AVAILABLE\");\n                        }\n                    } else {\n                        trackCreationAttempts.push(\"qe.project.getActiveSequence() - FAILED\");\n                    }\n                } catch (qeAddError) {\n                    trackCreationAttempts.push(\"qe.addTracks() - ERROR: \" + qeAddError.toString());\n                }\n            }\n            \n            // Attempt 2: Try alternative QE methods\n            if (!newTrack && result.debug.qeEnabled) {\n                try {\n                    const qeSequence = qe.project.getActiveSequence();\n                    if (qeSequence && typeof qeSequence.insertTracks === 'function') {\n                        qeSequence.insertTracks(0, 1); // Insert 1 audio track\n                        newTrack = true;\n                        trackCreationAttempts.push(\"qe.insertTracks(0, 1) - SUCCESS\");\n                    } else {\n                        trackCreationAttempts.push(\"qe.insertTracks() - NOT AVAILABLE\");\n                    }\n                } catch (qeInsertError) {\n                    trackCreationAttempts.push(\"qe.insertTracks() - ERROR: \" + qeInsertError.toString());\n                }\n            }\n            \n            // Attempt 3: Try direct sequence manipulation\n            if (!newTrack) {\n                try {\n                    // Some Adobe apps support this pattern\n                    if (typeof sequence.insertAudioTrack === 'function') {\n                        newTrack = sequence.insertAudioTrack();\n                        trackCreationAttempts.push(\"sequence.insertAudioTrack() - SUCCESS\");\n                    } else {\n                        trackCreationAttempts.push(\"sequence.insertAudioTrack() - NOT AVAILABLE\");\n                    }\n                } catch (e3) {\n                    trackCreationAttempts.push(\"sequence.insertAudioTrack() - ERROR: \" + e3.toString());\n                }\n            }\n            \n            result.debug.trackCreationAttempts = trackCreationAttempts;\n            \n            if (!newTrack) {\n                // If we can't create tracks, fall back to using existing tracks\n                result.debug.trackCreationFailed = true;\n                result.debug.apiLimitation = \"Premiere Pro ExtendScript may not support dynamic track creation\";\n                result.debug.fallbackStrategy = \"Will place on existing tracks, even if there are conflicts\";\n                \n                // Use the last available track instead of creating a new one\n                finalTrackIndex = sequence.audioTracks.numTracks - 1;\n                foundAvailableTrack = true;\n                result.debug.usingFallbackTrack = finalTrackIndex;\n                result.debug.createdNewTrack = false;\n            } else {\n                // Successfully created a new track (hopefully with QE API!)\n                result.debug.afterTrackCreation = sequence.audioTracks.numTracks;\n                \n                // Check if track count actually increased\n                if (sequence.audioTracks.numTracks > result.debug.beforeTrackCreation) {\n                    // Success! Track was actually created - use the NEW track at the end\n                    finalTrackIndex = sequence.audioTracks.numTracks - 1; // This should be the NEW empty track\n                    result.debug.createdNewTrack = true;\n                    result.debug.newTrackIndex = finalTrackIndex;\n                    result.debug.trackCreationSuccess = true;\n                    result.debug.trackCreationConfirmed = \"YES - from \" + result.debug.beforeTrackCreation + \" to \" + result.debug.afterTrackCreation;\n                    result.debug.usingNewlyCreatedTrack = \"Track \" + (finalTrackIndex + 1) + \" (should be empty)\";\n                    foundAvailableTrack = true;\n                } else {\n                    // Track creation call succeeded but no new track appeared\n                    result.debug.trackCreationConfirmed = \"NO - track count stayed \" + sequence.audioTracks.numTracks;\n                    result.debug.trackCreationFailed = true;\n                    \n                    // Fall back to using existing tracks\n                    finalTrackIndex = sequence.audioTracks.numTracks - 1;\n                    foundAvailableTrack = true;\n                    result.debug.usingFallbackTrack = finalTrackIndex;\n                    result.debug.createdNewTrack = false;\n                }\n            }\n        }\n        \n        result.debug.placementAttempts = placementAttempts;\n        result.debug.finalTrackIndex = finalTrackIndex;\n        result.debug.totalTracksNow = sequence.audioTracks.numTracks;\n        \n        // Place audio at specific time\n        result.step = \"placing_audio\";\n        const targetTrack = sequence.audioTracks[finalTrackIndex];\n        \n        try {\n            targetTrack.insertClip(importedItem, timeSeconds);\n            result.debug.placementMethod = \"insertClip at specific time\";\n            result.debug.placementSuccess = true;\n        } catch (insertError) {\n            result.error = \"Failed to insert clip at time \" + timeSeconds + \"s: \" + insertError.toString();\n            return result;\n        }\n        \n        // Success!\n        result.success = true;\n        result.step = \"completed\";\n        \n        let message = \"Audio placed at \" + formatTime(timeSeconds) + \" on track \" + (finalTrackIndex + 1);\n        if (result.debug.createdNewTrack) {\n            message += \" (new track created)\";\n        } else if (finalTrackIndex !== startingTrackIdx) {\n            message += \" (avoided conflicts)\";\n        }\n        \n        result.message = message;\n        result.fileName = importedItem.name;\n        result.trackIndex = finalTrackIndex;\n        result.position = timeSeconds;\n        result.positionFormatted = formatTime(timeSeconds);\n        \n        return result;\n        \n    } catch (error) {\n        result.error = \"Exception in step '\" + result.step + \"': \" + error.toString();\n        return result;\n    }\n};\n\n/**\n * Standard audio import at playhead position (for non-in/out mode)\n */\nexport const importAndPlaceAudio = (filePath: string, trackIndex: number = 0) => {\n    try {\n        const sequence = app.project.activeSequence;\n        if (!sequence) {\n            return { success: false, error: \"No active sequence\" };\n        }\n        \n        const currentTime = sequence.getPlayerPosition();\n        return importAndPlaceAudioAtTime(filePath, currentTime.seconds, trackIndex);\n        \n    } catch (error) {\n        return {\n            success: false,\n            error: \"Failed to place at playhead: \" + error.toString()\n        };\n    }\n};\n\n/**\n * Utility function to format time as HH:MM:SS\n */\nfunction formatTime(seconds: number): string {\n    if (isNaN(seconds) || seconds < 0) {\n        return \"00:00:00\";\n    }\n    \n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n    \n    const hoursStr = hours < 10 ? \"0\" + hours : hours.toString();\n    const minutesStr = minutes < 10 ? \"0\" + minutes : minutes.toString();\n    const secsStr = secs < 10 ? \"0\" + secs : secs.toString();\n    \n    return hoursStr + \":\" + minutesStr + \":\" + secsStr;\n}\n\n/**\n * Test function for Bolt CEP connectivity\n */\nexport const testConnection = () => {\n    return {\n        success: true,\n        message: \"AI SFX Generator ExtendScript connected via Bolt CEP!\",\n        timestamp: (new Date()).toISOString(),\n        premiereVersion: app.version,\n        projectName: app.project ? app.project.name : \"No project\"\n    };\n};\n\n/**\n * Get basic app info for debugging\n */\nexport const getAppInfo = () => {\n    return {\n        appName: app.appName,\n        version: app.version,\n        projectName: app.project ? app.project.name : \"No project\",\n        hasActiveSequence: !!(app.project && app.project.activeSequence),\n        sequenceName: (app.project && app.project.activeSequence) ? app.project.activeSequence.name : null\n    };\n};","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as aeft from \"./aeft/aeft\"; // BOLT_AEFT_ONLY\nimport * as ame from \"./ame/ame\"; // BOLT_AME_ONLY\nimport * as anim from \"./anim/anim\"; // BOLT_ANIM_ONLY\nimport * as audt from \"./audt/audt\"; // BOLT_AUDT_ONLY\nimport * as idsn from \"./idsn/idsn\"; // BOLT_IDSN_ONLY\nimport * as ilst from \"./ilst/ilst\"; // BOLT_ILST_ONLY\nimport * as kbrg from \"./kbrg/kbrg\"; // BOLT_KBRG_ONLY\nimport * as phxs from \"./phxs/phxs\"; // BOLT_PHXS_ONLY\nimport * as ppro from \"./ppro/ppro\"; // BOLT_PPRO_ONLY\n\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\n\n// A safe way to get the app name since some versions of Adobe Apps broken BridgeTalk in various places (e.g. After Effects 24-25)\n// in that case we have to do various checks per app to deterimine the app name\n\nconst getAppNameSafely = (): ApplicationName | \"unknown\" => {\n  const compare = (a: string, b: string) => {\n    return a.toLowerCase().indexOf(b.toLowerCase()) > -1;\n  };\n  const exists = (a: any) => typeof a !== \"undefined\";\n  const isBridgeTalkWorking =\n    typeof BridgeTalk !== \"undefined\" &&\n    typeof BridgeTalk.appName !== \"undefined\";\n\n  if (isBridgeTalkWorking) {\n    return BridgeTalk.appName;\n  } else if (app) {\n    //@ts-ignore\n    if (exists(app.name)) {\n      //@ts-ignore\n      const name: string = app.name;\n      if (compare(name, \"photoshop\")) return \"photoshop\";\n      if (compare(name, \"illustrator\")) return \"illustrator\";\n      if (compare(name, \"audition\")) return \"audition\";\n      if (compare(name, \"bridge\")) return \"bridge\";\n      if (compare(name, \"indesign\")) return \"indesign\";\n    }\n    //@ts-ignore\n    if (exists(app.appName)) {\n      //@ts-ignore\n      const appName: string = app.appName;\n      if (compare(appName, \"after effects\")) return \"aftereffects\";\n      if (compare(appName, \"animate\")) return \"animate\";\n    }\n    //@ts-ignore\n    if (exists(app.path)) {\n      //@ts-ignore\n      const path = app.path;\n      if (compare(path, \"premiere\")) return \"premierepro\";\n    }\n    //@ts-ignore\n    if (exists(app.getEncoderHost) && exists(AMEFrontendEvent)) {\n      return \"ame\";\n    }\n  }\n  return \"unknown\";\n};\n\nswitch (getAppNameSafely()) {\n  // BOLT_AEFT_START\n  case \"aftereffects\":\n  case \"aftereffectsbeta\":\n    host[ns] = aeft;\n    break;\n  // BOLT_AEFT_END\n\n  // BOLT_AME_START\n  case \"ame\":\n  case \"amebeta\":\n    host[ns] = ame;\n    break;\n  // BOLT_AME_END\n\n  // BOLT_ANIM_START\n  case \"animate\":\n  case \"animatebeta\":\n    host[ns] = anim;\n    break;\n  // BOLT_ANIM_END\n\n  // BOLT_AUDT_START\n  case \"audition\":\n  case \"auditionbeta\":\n    host[ns] = audt;\n    break;\n  // BOLT_AUDT_END\n\n  // BOLT_IDSN_START\n  case \"indesign\":\n  case \"indesignbeta\":\n    host[ns] = idsn;\n    break;\n  // BOLT_IDSN_END\n\n  // BOLT_ILST_START\n  case \"illustrator\":\n  case \"illustratorbeta\":\n    host[ns] = ilst;\n    break;\n  // BOLT_ILST_END\n\n  // BOLT_KBRG_START\n  case \"bridge\":\n  case \"bridgebeta\":\n    host[ns] = kbrg;\n    break;\n  // BOLT_KBRG_END\n\n  // BOLT_PHXS_START\n  case \"photoshop\":\n  case \"photoshopbeta\":\n    host[ns] = phxs;\n    break;\n  // BOLT_PHXS_END\n\n  // BOLT_PPRO_START\n  case \"premierepro\":\n  case \"premiereprobeta\":\n    host[ns] = ppro;\n    break;\n  // BOLT_PPRO_END\n}\n\nconst empty = {};\n// prettier-ignore\nexport type Scripts = typeof empty\n  & typeof aeft // BOLT_AEFT_ONLY\n  & typeof ame // BOLT_AME_ONLY\n  & typeof anim // BOLT_ANIM_ONLY\n  & typeof audt // BOLT_AUDT_ONLY\n  & typeof idsn // BOLT_IDSN_ONLY\n  & typeof ilst // BOLT_ILST_ONLY\n  & typeof kbrg // BOLT_KBRG_ONLY\n  & typeof phxs // BOLT_PHXS_ONLY\n  & typeof ppro // BOLT_PPRO_ONLY\n  ;\n\n// https://extendscript.docsforadobe.dev/interapplication-communication/bridgetalk-class.html?highlight=bridgetalk#appname\ntype ApplicationName =\n  | \"aftereffects\"\n  | \"aftereffectsbeta\"\n  | \"ame\"\n  | \"amebeta\"\n  | \"audition\"\n  | \"auditionbeta\"\n  | \"animate\"\n  | \"animatebeta\"\n  | \"bridge\"\n  | \"bridgebeta\"\n  // | \"flash\"\n  | \"illustrator\"\n  | \"illustratorbeta\"\n  | \"indesign\"\n  | \"indesignbeta\"\n  // | \"indesignserver\"\n  | \"photoshop\"\n  | \"photoshopbeta\"\n  | \"premierepro\"\n  | \"premiereprobeta\";\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","allowSkipTSA","installModules","copyAssets","copyZipAssets","alert","eventObj","app","inPoint","outPoint","$","success","error","hasInPoint","hasOutPoint","seconds","formatted","duration","audioTrackCount","videoTrackCount","source","result","isActuallySet","rawValue","isValid","step","debug","importedItem","aiSfxBin","trackIndex","hasConflict","timePosition","trackName","finalTrackIndex","foundAvailableTrack","trackCreationAttempts","qeSequence","newTrack","targetTrack","message","timestamp","hasActiveSequence","sequenceName","host"],"mappings":"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H;;;AAGDlB;;;AAGAA;AAEA;;AAGAA;AACA;AACH;AACJ;AAED;AACA;AACA;;AACA;;;;AAEQ;;;;AAEaV;AAAgBC;;AAC5B;;AAED;;;;AAKID;AACAC;;AAEP;AACJ;AAED;AACA;AACA;;AACA;;AAEQ;AACH;;;;;AAMD;AACA;AACA;;AAGH;AAED;AACA;AACA;;;AACA;;AAEQD;AACA4B;AACAC;;;;AAIP;AAED;AACA;AACA;;AACA;;;;;AAKQC;AACAC;;AAEP;;;;;;;;;;;;AC1kBD;AAGA;;AAEA;;AAEI;;;AAEF;;;;AACA;;AAIA;;;AAGE;AACA;AACE;AACA;;;;;;AAMD;;;AAED;AACE;AACA;;;AAGD;;;AAED;AACE;AACA;;AAED;;;;AAGC;AACD;AACF;;AACD;AACD;;AAED;AACE;AACA;AACA;AACEC;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AAEA;;AACA;AACA;AACEA;AACA;AACF;AA9DF;AA+EA"}